# 服务发现的背景


## 从单体到微服务

现在基本上已经没有单体应用的，基本上都是微服务架构。

![](https://oscimg.oschina.net/oscnet/up-07a15a546529731560f4d71f7b0a4b5aa10.png)

## 微服务架构的根本问题

微服务架构有着两个根本的问题。

在微服务架构中，又着两个角色，服务的提供者：**服务端**，服务的使用者：**消费端/客户端**

第一个问题：一个服务可能部署了多个节点，那么客户端如何得知都有哪些节点呢？

第二个问题：一个请求最终肯定是由一个服务端处理的，那个多个服务端的情况下，客户的请求到底由谁处理呢?

![](https://oscimg.oschina.net/oscnet/up-0072a942c952aa132d562f0fbde467c7c54.png)

由此引出两个技术： **服务发现** 和 **负载均衡**

> 这里的负载均衡值得是客户端的负载均衡


## 解决办法

通过代理的方式，客户端可以找到服务端。

![](https://oscimg.oschina.net/oscnet/up-a5e81ae22d51d557db226e0a63bd45d420a.png)

根据代理组件存放的位置不同，衍生出很多不同的模式


### 传统集中式代理

代理放到消费者和服务端中间，集中独立部署的。

![](https://oscimg.oschina.net/oscnet/up-fbfc10fd25910eeb780b3f1b37751091976.png)

这种模式下如何进行服务端的发现呢？

一般的情况下，是由专门的人员比如专门的运维团队来进行管理，当后端微服务上线的时，将服务的信息添加到Nginx中。

客户端如何发现服务呢？

通过DNS域名解析，客户端首先找到代理，然后在解析运维人员之前配置的信息，路由到服务器上

> 比如user.com分配到UserServer上面。

中间的代理有两种，一种是硬件的代理F5，另一种是软件的代理，比如Nginx


### 服务注册中心+客户端嵌入式代理

代理挪到客户端。一般需要注册中心配合使用。

![](https://oscimg.oschina.net/oscnet/up-955281eabe435f981d54158846eb19d5527.png)

后端的服务自注册到注册中心上面，客户端可以自发现有哪些服务，然后通过负载均衡的策略，把请求路由到正确的服务上。

这种方式会受客户端语言的影响。

### 主机独立进程代理

代理即不放在服务端也不放在客户端的代码里，而是在每个客户端的主机上，部署一个进程。

当前主机的多个客户端，通过代理进程，可以访问服务端。

![](https://oscimg.oschina.net/oscnet/up-4dcb3d49dea048291a9f9f07567fdfca61b.png)


### 上面三种模式比对

![](https://oscimg.oschina.net/oscnet/up-66b2ba44aef78fe6ed76a43e9955026b0a0.png)

 

## 集中代理模式的两个变体

代理模式是目前比较主流也是非常好用的模式。

### 变体1

服务的注册不用运维人员注册，而是通过注册中心实现自注册和自发现。

![](https://oscimg.oschina.net/oscnet/up-961619d1f685f12d91ab86bdabb0dd7e895.png)

### 变体2

同样使用注册中心，但是不适用自注册的功能。因为自注册的话需要服务进程引入注册中心的客户端，这样才能实现自注册。

![](https://oscimg.oschina.net/oscnet/up-61e19ca5b3232db002904b4815d096f5651.png)

这种方式，不需要引入每个服务进程都引入注册中心的客户端程序。

而是在注册中心上面提供一个页面或者接口，可以手动的添加注册后端服务。注册中心可以定期检查后端服务。